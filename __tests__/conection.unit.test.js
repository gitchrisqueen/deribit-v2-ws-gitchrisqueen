/*
 * Copyright (c) 2020. Christopher Queen Consulting LLC (http://www.ChristopherQueenConsulting.com/)
 */

//'use strict'

const Connection = require('../connection');
//import Connection from '../connection';

jest.mock('../connection', () => {
     // Get the actual class implementation
    const actualConnection = jest.requireActual('../connection').default;
    // Return a mock constructor function
    return jest.fn().mockImplementation((key, secret, domain, debug) => {
        return {
            ...new actualConnection(key, secret, domain, debug), // Spread the actual instance
            connected: false,
            authenticated: false,
            connect: jest.fn().mockImplementation(function () {
                this.connected = true;
                this.authenticate();
                return Promise.resolve(true);
            }),
            authenticate: jest.fn().mockImplementation(function () {
                this.authenticated = true;
                this.token = 'mockToken';
                this.refreshToken = 'mockRefreshToken';
                return Promise.resolve(true);
            })


        }
    });
});

let con;
let key;
let secret;
let domain;
let debug;

jest.setTimeout(10000); // 10 seconds

beforeAll(() => {

    key = 'xxxxx';
    secret = 'yyyyy';
    domain = 'test.deribit.com';
    debug = false;

    con = new Connection({key, secret, domain, debug});
});

afterAll(() => {
    return con.end();
});

describe('constructor()', () => {

    test('expects property connected = true', () => {
        expect(con).toHaveProperty('connected', false);
    });

    test('expects property authenticated = false', () => {
        expect(con).toHaveProperty('authenticated', false);
    });

});


describe('connect()', () => {
    beforeAll(() => {
        con.connect();
    });

    test('expects property connected = true', () => {
        expect(con).toHaveProperty('connected', true);
    });
    test('expects property token', () => {
        expect(con).toHaveProperty('token');
    });
    test('expects property refreshToken', () => {
        expect(con).toHaveProperty('refreshToken');
    });
    test('expects property authenticated = true', () => {
        expect(con).toHaveProperty('authenticated', true);
    });

});


// Generated by CodiumAI

describe('cancel_order_by_label', () => {

    // Successfully cancels an order by label when connected and authenticated
    it('should successfully cancel an order by label when connected and authenticated', async () => {
        const connection = new Connection({key, secret, domain, debug});

        connection.connected = true;
        connection.authenticated = true;
        connection.request = jest.fn().mockResolvedValue('Order cancelled');

        const result = await connection.cancel_order_by_label('test-label');

        expect(connection.request).toHaveBeenCalledWith('private/cancel_by_label', {'label': 'test-label'});
        expect(result).toBe('Order cancelled');
    });

    // Attempts to cancel an order when not connected
    it('should throw an error when attempting to cancel an order while not connected', async () => {
        const connection = new Connection();
        connection.connected = false;
        connection.reconnecting = false;

        await expect(connection.cancel_order_by_label('test-label')).rejects.toThrow('Not connected.');
    });
});


